<!--Sue Strack-->
<html lang="en">
    <head>
        <title>Chapter 5: Programming Algorithms & Software Testing</title>
    </head>
    <body style="color:#ffff00; background-color:#000000; font-family:calibri;">
    <h1>Chapter 5: Programming Algorithms & Software Testing</h1>
    <p>Phases of computer program development</p>
    <ol>
        <li>Phase 1: Understand the problem</li>
        <li>Phase 2: Design an algorithm to solve the problem</li>
        <li>Phase 3: Write the program code in appropriate language based on the algorithm</li>
        <li>Phase 4: Enter the program and save</li>
        <li>Phase 5: Execute the program</li>
        <li>Phase 6: Test the program, find errors and debug, then retest</li>
        <li>Phase 7: Document and evaluate the program</li>
    </ol>
    <p>Programming structures</p>
    <ul>
        <li>Sequential structure: Top-down execution</li>
        <li>Decision structures: if/then/else</li>
        <li>Iterative (Looping): </li>
        <ul>
        <li>While loop: continue looping as long 
            as something is true</li>
        <li>repeat/until loop: continue looping until something is true</li>
        <li>for loop: loop a given number of times</li></ul>
        <li>Recursive structures:</li>
        <ul><li>Repeat a set of instructions as a subtask of itself</li>
        <li>Repetition continues until: degenerative case, which a termination 
            condition, is met (degenerative case is also called a "base case")</li>
        </ul></ul>
    <p>Two classic programming/database problems</p>
    <ul>
        <li>Sorting: Descending order/Ascending order</li>
        <li>Sorting numbers</li>
        <li>Sorting strings (in accordance with ASCII values)</li>
        <li>Searching: Find specific data that meet a certain criteria</li>
        <li>In databse:</li>
        <li>Filters: temporary search</li>
        <li>Queries: search criteria are saved so they don't have to be 
            recreated</li>
        <li>Two popular search techniques:</li>
        <li>Sequential search: search from top to bottom or bottom to top,
            one at a time</li>
        <li>Binary search: only works if data is SORTED first. Start in the 
            middle, then go to half of that, etc.</li>
    </ul>
    <p>Two classic program goals:</p>
    <ol>
        <li>Efficiency: Program takes minimal time and/or resources</li>
        <li>Correctness: Program runs in expected ways and works for all
            expected conditions</li>
    </ol>
    </ul>
    <table border="1" style="text-align:center;" width="560">
       <thead>
        <tr>
            <th colspan="2">Software Testing and Verification</th>
        </tr>
       </thead> 
        <tr style="font-weight:bold; font-size: 120%;">
            <td>Kinds of tests</td>
            <td>Definition</td>
        </tr>
        <tr>
            <td>Acceptance testing:</td>
            <td>Verifying whether the whole system works as intended</td>
        </tr>
        <tr>
            <td>Integration testing:</td>
            <td>Ensuring that software components or functions operate together</td>
        </tr>
        <tr>
            <td>Unit testing</td>
            <td>Validating that each software unit performs as expected. A unit is 
                the smallest testable component of an application</td>
        </tr>
        <tr>
            <td>Functional testing</td>
            <td>Checking functions by emulating business scenarios, based on 
                functional requirements. Black--box testing is a common way 
                to verify functions.</td>
        </tr>
        <tr>
            <td>Performance testing</td>
            <td>Testing how the software performs under different workloads. 
                Load testing, for example, is used to evaluate performance 
                under real-life load conditions</td>
        </tr>
        <tr>
            <td>Regression testing</td>
            <td>Checking whether new features break or degrade functionality.
                Sanity testing can be used to verify menus, functions and commands 
                at the surface level, when there is no time for a full regression 
                test</td>
        </tr>
        <tr>
            <td>Stress testing</td>
            <td>Testing how much strain the system can take before it fails. 
                Considered to be a type of non-functional testing</td>
        </tr>
        <tr>
            <td>Usability testing</td>
            <td>Validating how well a customer can use a system or web 
                application to complete a task</td>
        </tr>
        <tr>
            <td colspan="2">Software testing is done to detect:</td>
        </tr>
        <tr>
            <td colspan="2">Architectural flaws</td>
        </tr>
        <tr>
            <td colspan="2">Poor design decisions</td>
        </tr>
        <tr>
            <td colspan="2">Invalid or incorrect functionality</td>
        </tr>
        <tr>
            <td colspan="2">Security vulnerabilities</td>
        </tr>
        <tr>
            <td colspan="2">Scalability issues</td>
        </tr>
        <tr>
            <td colspan="2">Testing best practices</td>
        </tr>
        <tr>
            <td>Continuous testing</td>
            <td>Automated and integrated testing that happens in real time 
                enabling software to be validated earlier in the process</td>
        </tr>
        <tr>
            <td>Configuration management</td>
            <td>A centerally controlled way of tracking what software builds to test. 
                Teams gain access to programs and there is authentication built in to 
                track and assist with compliance regulations</td>
        </tr>
        <tr>
            <td>Service virtualization</td>
            <td>The ability to test not yet finished environments by simulating the 
                finished product and being able to test sooner. They can test different 
                scenarios without having to modify the original environment</td>
        </tr>
        <tr>
            <td>Defect or bug tracking</td>
            <td>Automated tools allow teams to track defects, measure their 
                scope and impact and uncover related issues</td>
        </tr>
        <tr>
            <td>Metrics and reporting</td>
            <td>Advanced tools integrate project metrics and present results in 
                a dashboard. Teams can quickly see the overall health of a project 
                and can monitor relationships between test, development and other elements</td>
        </tr>
    </table>
    <tfoot colspan="2"><i><a href="https://www.ibm.com/topics/software-testing">From IBM What is software testing?</a></i></tfoot>
    </body>
</html>